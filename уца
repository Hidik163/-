function Groupbox:CreateSlider(ElementSettings, Index)

					--[[
					ElementSettings = {
						Name = string,
						Icon = number, **
						
						CurrentValue = number, **
						Range = table{number, number}, 
						Increment = number, **
						HideMax = bool, **
						
						Callback = function(number),
					}
					]]

					ElementSettings.CurrentValue = ElementSettings.CurrentValue or ElementSettings.Range[1]
					ElementSettings.Increment = ElementSettings.Increment or 1
					ElementSettings.HideMax = ElementSettings.HideMax or false
					ElementSettings.Suffix = ElementSettings.Suffix and (ElementSettings.Suffix == "%" and `{ElementSettings.Suffix}` or ` {ElementSettings.Suffix}`) or ""

					local Element = {
						Values = ElementSettings,
						Class = "Slider",
						SLDragging = false,
						IgnoreConfig = ElementSettings.IgnoreConfig
					}
					local isTyping = false
					local ignoreNext = false

					local tooltip

					Element.Instance = GroupboxTemplateInstance.Slider_TEMPLATE:Clone()
					Element.Instance.Visible = true
					Element.Instance.Parent = Groupbox.ParentingItem

					Element.Instance.Name = "SLIDER_" .. Index
					Element.Instance.Header.Text = Element.Values.Name
					Element.Instance.Header.Icon.Visible = not String.IsEmptyOrNull(Element.Values.Icon)
					if Element.Instance.Header.Icon.Visible == false then
						Element.Instance.Header.UIPadding.PaddingLeft = UDim.new(0,6)
					else
						Element.Instance.Header.UIPadding.PaddingLeft = UDim.new(0,32)
					end
					Element.Instance.Header.Icon.Image = not String.IsEmptyOrNull(Element.Values.Icon) and "rbxassetid://" .. Element.Values.Icon or ""

					tooltip = AddToolTip(Element.Values.Tooltip, Element.Instance)

					local function Set(Value : number)
						if Value then
							Element.Values.CurrentValue = Value

							Tween(
								Element.Instance.PART_Backdrop.PART_Progress,

								{Size = UDim2.new((Value - Element.Values.Range[1]) / (Element.Values.Range[2] - Element.Values.Range[1]), 0, 1, 0)},
								nil,
								Tween.Info(nil,nil,0.2)
							)
							Element.Instance.Value.input.Text = tostring(Value)
							Element.Instance.Value.input.CursorPosition = #Element.Instance.Value.input.Text + 2


							local Success,Response = pcall(function()
								Element.Values.Callback(Value)
							end)

							if not Success then
								Element.Instance.Header.Text = "Callback Error"
								warn(`Starlight Interface Suite - Callback Error | {Element.Values.Name} ({Index})`)
								print(Response)
								if WindowSettings.NotifyOnCallbackError then
									Starlight:Notification({
										Title = Element.Values.Name.." Callback Error",
										Content = tostring(Response),
										Icon = 129398364168201
									})
								end
								wait(0.5)
								Element.Instance.Header.Text = ElementSettings.Name
							end
						end				


					end

					Element.Instance.PART_Backdrop.Interact.InputBegan:Connect(function(Input)
						if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then 
							Element.SLDragging = true 
						end 
					end)

					Element.Instance.PART_Backdrop.Interact.InputEnded:Connect(function(Input) 
						if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then 
							Element.SLDragging = false 
						end 
					end)
					
					Element.Instance.PART_Backdrop.Interact.MouseButton1Down:Connect(function(X)

						local Current = Element.Instance.PART_Backdrop.PART_Progress.AbsolutePosition.X + Element.Instance.PART_Backdrop.PART_Progress.AbsoluteSize.X
						local Start = Current
						local Location = X
						local Loop; Loop = RunService.Stepped:Connect(function()
							if Element.SLDragging then
								Location = Mouse.X
								Current = Current + 0.025 * (Location - Start)

								if Location < Element.Instance.PART_Backdrop.AbsolutePosition.X then
									Location = Element.Instance.PART_Backdrop.AbsolutePosition.X
								elseif Location > Element.Instance.PART_Backdrop.AbsolutePosition.X + Element.Instance.PART_Backdrop.AbsoluteSize.X then
									Location = Element.Instance.PART_Backdrop.AbsolutePosition.X + Element.Instance.PART_Backdrop.AbsoluteSize.X
								end

								if Current < Element.Instance.PART_Backdrop.AbsolutePosition.X  then
									Current = Element.Instance.PART_Backdrop.AbsolutePosition.X 
								elseif Current > Element.Instance.PART_Backdrop.AbsolutePosition.X + Element.Instance.PART_Backdrop.AbsoluteSize.X then
									Current = Element.Instance.PART_Backdrop.AbsolutePosition.X + Element.Instance.PART_Backdrop.AbsoluteSize.X
								end

								if Current <= Location and (Location - Start) < 0 then
									Start = Location
								elseif Current >= Location and (Location - Start) > 0 then
									Start = Location
								end

								local percentage = (Location - Element.Instance.PART_Backdrop.AbsolutePosition.X) / Element.Instance.PART_Backdrop.AbsoluteSize.X
								Tween(
									Element.Instance.PART_Backdrop.PART_Progress,

									{Size = UDim2.new(percentage, 0, 1, 0)},

									nil,
									Tween.Info(nil,nil,0.2)
								)
								
								task.wait()

								local NewValue = ((Element.Values.Range[2] - Element.Values.Range[1]) * percentage) + Element.Values.Range[1]

								NewValue = math.floor(NewValue / Element.Values.Increment + 0.5) * (Element.Values.Increment * 10000000) / 10000000

								Element.Instance.Value.input.Text = tostring(NewValue)

								if Element.Values.CurrentValue ~= NewValue then
									local Success,Response = pcall(function()
										Element.Values.Callback(NewValue)
									end)

									if not Success then
										Element.Instance.Header.Text = "Callback Error"
										warn(`Starlight Interface Suite - Callback Error | {Element.Values.Name} ({Index})`)
										print(Response)
										if WindowSettings.NotifyOnCallbackError then
											Starlight:Notification({
												Title = Element.Values.Name.." Callback Error",
												Content = tostring(Response),
												Icon = 129398364168201
											})
										end
										wait(0.5)
										Element.Instance.Header.Text = ElementSettings.Name
									end

									Element.Values.CurrentValue = NewValue
								end
							else
								Tween(
									Element.Instance.PART_Backdrop.PART_Progress,

									{Size = UDim2.new((Location - Element.Instance.PART_Backdrop.AbsolutePosition.X) / Element.Instance.PART_Backdrop.AbsoluteSize.X, 0, 1, 0)},

									nil,
									Tween.Info(nil,nil,0.2)
								)
								Loop:Disconnect()
							end
						end)
					end)
					
					Element.Instance.PART_Backdrop.PART_Progress:GetPropertyChangedSignal("Size"):Connect(function()
						if Element.Instance.PART_Backdrop.PART_Progress.AbsoluteSize.X <= 0 then
							Element.Instance.PART_Backdrop.PART_Progress.DropShadowHolder.DropShadow.Size = UDim2.new(1,0,1,0)
							return
						end
						Element.Instance.PART_Backdrop.PART_Progress.DropShadowHolder.DropShadow.Size = UDim2.new(1,22,1,22)
					end)
					
					local input = Element.Instance.Value.input
					local updating = false
					local lastValid = input.Text or ""

					input:GetPropertyChangedSignal("Text"):Connect(function()
						if updating then return end

						local tb = input
						local newText = tb.Text or ""
						if newText == lastValid then return end

						local sanitizedBuilder = {}
						local dotUsed = false
						local survivorsBeforeCursor = 0
						local cursorPos = tb.CursorPosition or (#newText + 1)

						for i = 1, #newText do
							local ch = newText:sub(i,i)
							if ch:match("%d") then
								table.insert(sanitizedBuilder, ch)
								if i < cursorPos then survivorsBeforeCursor = survivorsBeforeCursor + 1 end
							elseif ch == "." and not dotUsed then
								dotUsed = true
								table.insert(sanitizedBuilder, ".")
								if i < cursorPos then survivorsBeforeCursor = survivorsBeforeCursor + 1 end
							end
						end

						local sanitized = table.concat(sanitizedBuilder)

						if sanitized ~= newText then
							updating = true
							tb.Text = sanitized
							task.wait()
							tb.CursorPosition = math.clamp(survivorsBeforeCursor + 1, 1, #sanitized + 1)
							updating = false
							lastValid = sanitized
						else
							lastValid = newText
						end

						if sanitized == "" or sanitized == "." or sanitized:sub(-1) == "." then
							return
						end

						local num = tonumber(sanitized)
						if not num then
							return
						end

						local minv = (Element.Values and Element.Values.Range and Element.Values.Range[1]) or -math.huge
						local maxv = (Element.Values and Element.Values.Range and Element.Values.Range[2]) or math.huge

						if num < minv then
							num = minv
							updating = true
							tb.Text = tostring(num)
							task.wait()
							tb.CursorPosition = #tb.Text + 1
							updating = false
							lastValid = tb.Text
						elseif num > maxv then
							num = maxv
							updating = true
							tb.Text = tostring(num)
							task.wait()
							tb.CursorPosition = #tb.Text + 1
							updating = false
							lastValid = tb.Text
						end

						Set(num)
					end)


					Element.Instance.Value.input.FocusLost:Connect(function()
						if Element.Instance.Value.input.Text == "" or Element.Instance.Value.input.Text == "." or Element.Instance.Value.input.Text == "0." then
							Set(Element.Values.CurrentValue)
							task.wait()
							Element.Instance.Value.input:ReleaseFocus()
						end
					end)

					Element.Instance.MouseEnter:Connect(function()
						Tween(Element.Instance.PART_Backdrop.PART_Progress.DropShadowHolder.DropShadow, {ImageTransparency = 0.1})
					end)
					Element.Instance.MouseLeave:Connect(function()
						Tween(Element.Instance.PART_Backdrop.PART_Progress.DropShadowHolder.DropShadow, {ImageTransparency = 0.9})
					end)

					Set(Element.Values.CurrentValue)
					Element.Instance.Value.max.Text = `{Element.Values.Suffix}` .. (not Element.Values.HideMax and `/{Element.Values.Range[2]}` or "")

					function Element:Destroy()
						Element.Instance:Destroy()
					end

					function Element:Set(NewElementSettings , NewIndex)
						NewIndex = NewIndex or Index

						for i,v in pairs(Element.Values) do
							if NewElementSettings[i] == nil then
								NewElementSettings[i] = v
							end
						end

						ElementSettings = NewElementSettings
						Index = NewIndex
						Element.Values = ElementSettings

						Element.Instance.Name = "SLIDER_" .. Index
						Element.Instance.Header.Text = Element.Values.Name
						Element.Instance.Header.Icon.Visible = not String.IsEmptyOrNull(Element.Values.Icon)
						if Element.Instance.Header.Icon.Visible == false then
							Element.Instance.Header.UIPadding.PaddingLeft = UDim.new(0,6)
						else
							Element.Instance.Header.UIPadding.PaddingLeft = UDim.new(0,32)
						end
						Element.Instance.Header.Icon.Image = not String.IsEmptyOrNull(Element.Values.Icon) and "rbxassetid://" .. Element.Values.Icon or ""

						tooltip.Text = Element.Values.Tooltip or tooltip.Text

						Set(Element.Values.CurrentValue)
						Element.Instance.Value.max.Text = `{Element.Values.Suffix}` .. not Element.Values.HideMax and `/{Element.Values.Range[2]}` or ""

						Starlight.Window.TabSections[Name].Tabs[TabIndex].Groupboxes[GroupIndex].Elements[Index].Values = Element.Values

					end

					function Element:Lock(Reason)
						Element.Instance.Lock_Overlay.Visible = true
						Element.Instance.Interactable = false
						Element.Instance.Lock_Overlay.Header.Text = Reason or ""
					end

					function Element:Unlock()
						Element.Instance.Lock_Overlay.Visible = false
						Element.Instance.Interactable = true
						Element.Instance.Lock_Overlay.Header.Text = ""
					end

					Starlight.Window.TabSections[Name].Tabs[TabIndex].Groupboxes[GroupIndex].Elements[Index] = Element
					return Starlight.Window.TabSections[Name].Tabs[TabIndex].Groupboxes[GroupIndex].Elements[Index]
				end
